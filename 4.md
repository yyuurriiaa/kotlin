## 4.1 클래스 정의
* sealed로 클래스 상속을 제한할 수 있음.

# 4.1.1 코틀린 인터페이스
* 코틀린 인터페이스 안에서 추상메서드 뿐 아니라 구현이 있는 메소드도 정의 가능.
* 하지만 필드는 정의 불가.

```kotlin
interface Clickable{
    fun click()
}
```

* extends, implements 대신 : 클래스명 으로 모두 처리함.
* 오버라이드시 override 변경자 반드시 사용.

```kotlin
class Button : Clickable{
    override fun click() = println("I was clicked")

}
```

* 상위 타입 구현 시, super 사용. 구체적 구현시 super<T> 사용.

# 4.1.2 open, final, abstract 변경자 : 기본적으로 final

* 코틀린의 클래스와 메소드는 기본적으로 final. 상속을 허용하려면 클래스 앞에 **open 변경자** 붙여야함.

* 오버라이드를 허용하고싶은 **메소드나 프로퍼티의 앞에도** open 변경자를 붙여야 함.

```kotlin
open class RichButton : Clockable{
    fun disable(){} // final 함수. 하위 클래스에서 오버라이드 불가능

    open fun animate() {} // open 함수. 오버라이드 가능

    override fun click() {} // open되어있는 메소드를 오버라이드함. 오버라이드 한 메소드는 열려있음
}
```

* 오버라이드 하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 하려면 메소드 앞에 final을 명시.

* abstract로 선언한 추상클래스의 **추상 멤버**는 항상 열려있기때문에 open 변경자를 명시할 필요가 없음.

```kotlin
abstract class Animated{
    abstract fun animate() // 추상함수. 

    open fun stopAnimating() // 비추상함수. open으로 오버라이드 허용함.

    fun animateTwice() // 비추상함수. final
}
```

* 인터페이스 멤버는 항상 열려있으며 final로 변경 불가능함.

# 4.1.3 가시성 변경자 : 기본적으로 공개

* 클래스 외부 접근을 제어함. public, protect, private, internal. internal은 같은 모듈 안에서만 볼 수 있음.

* 코틀린의 기본 가시성은 **자바와 달리 public**

* 코틀린에서는 최상위 선언(클래스, 함수, 프로퍼티 등)에 대해 private 가시성을 허용함.

```kotlin
internal open class TalkativeButton : Focusable{
    private fun yell() = println("Hey!")
    protected fun whisper() = println("Let's talk")
}

fun TalkativeButton.giveSpeech() { // error : 확장 함수 public 멤버가 internal 수신타입인 TalkativeButton을 노출
    yell() // error : yell은 TalkativeButton의 private 멤버
    whisper() // error : whisper 는 TalkativeButton의 protected 멤버
}
```

* 자바에서는 같은 패키지 안에서 protected 멤버에 접근 가능 / 코틀린에서는 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 protected에 접근 가능

# 4.1.4 내부 클래스와 중첩된 클래스 : 기본적으로 중첩 클래스

* 코틀린의 중첩 클래스는 명시적으로 요청하지 않는 이상(inner) **바깥쪽 클래스 인스턴스에 대한 접근 권한이 없음**.

```kotlin
class Button : View{
    override fun getCurrentState() : State = ButtonState()

    override fun restoreState(state : State) {}

    class ButtonState : State {}
}
```

* 코틀린 중첩 클래스에 **아무런 변경자가 붙지 않으면 자바 static 중첩 클래스**와 같음.

* 바깥쪽 클래스에 대한 참조를 포함하게 하려면 **inner 변경자**를 붙여야 함.

* 코틀린 내부 클래스 안에서 바깥쪽 클래스 Outer 의 참조에 접근하려면 this@Outer 라고 써야함

```kotlin
class Outer{
    inner class Inner{
        fun getOuterReference() : Outer = this@Outer
    }
}
```

# 4.1.5 봉인된 클래스 : 클래스 계층 정의 시 계층 확장 제한

* 상위 클래스에 sealed 변경자를 붙여서 그 상위 클래스를 상속한 하위 클래스 정의를 제한 할 수 있음.

* sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 함.

```kotlin

