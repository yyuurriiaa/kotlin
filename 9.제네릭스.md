# 9.제네릭스

* 실체화한 타입 파라미터를 사용하면 인라인 함수 호출에서 타입 인자로 쓰인 구체적인 타입을 실행 시점에 알 수 있다

* 선언 지점 변성을 사용하면 기저 타입은 같지만 타입 인자가 다른 두 제네릭 타입 Type<A>와 Type<B>가 있을 때 타입 인자 A와 B의 상위/하위 타입 관계에 따라 두 제네릭 타입의 상위/하위 타입 관계가 어떻게 되는지 지정할 수 있다

## 9.1 제네릭 타입 파라미터

* 제네릭스를 사용하면 타입 파라미터를 받는 타입을 정의할 수 있다

* 코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추측할 수 있다

* 빈 리스트를 만들어야 한다면 타입 인자를 추론할 근거가 없기 때문에 직접 타입 인자를 명시해야 한다

### 9.1.1 제네릭 함수와 프로퍼티

* 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 한다

```kotlin
fun <T> List<T>.slice(indices : IntRange) : List<T>{...}

>>> val letters = ('a'..'z').toList()
>>> println(letters.slice<char>(0..2))
[a,b,c]
>>> println(letters.slice(10..13))
[k,l,m,n]
```

* 클래스나 인터페이스 안에 정의된 메소드, 확장 함수 또는 최상위 함수에서 타입 파라미터를 선언할 수 있다

### 9.1.2 제네릭 클래스 선언

* 자바와 마찬가지로 코틀린에서도 타입 파라미터를 넣은 뒤 <>를 클래스 또는 인터페이스 이름 뒤에 붙이면 클래스나 인터페이스를 제네릭하게 만들 수 있다

### 9.1.3 타입 파라미터 제약

* **타입 파라미터 제약**은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능이다

* 어떤 타입을 제네릭 타입의 타입 파라미터에 대한 상한으로 지정하면 그 제네릭 타입을 인스턴스화할 때 사용하는 타입 인자는 반드시 그 상한 타입이거나 그 상한 타입의 하위 타입이어야 한다

```kotlin
fun <T : Number> List<T>.sum() : T // Number이거나 Number의 하위 타입이어야 한다
```

* 타입 파라미터에 대해 둘 이상의 제약을 가해야 하는 경우, 약간 다른 구문을 사용한다

```kotlin
fun <T> ensureTrailingPeroid(seq : T) where T : CharSequence, T : Appendable { // T 가 CharSequence와 Appendable을 반드시 구현해야 함
    if (!seq.endsWith('.')) {
        seq.append('.')
    }
}
```

### 9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정

* 아무런 상한을 정하지 않은 타입 파라미터는 결과적으로 Any?를 상한으로 정한 파라미터와 같다

* 널 가능성을 제외한 아무런 제약도 필요 없다면 Any? 대신 Any를 상한으로 사용

```kotlin
class Processor<T : Any> {
    fun process(value : T) {
        value.hashCode()
    }
}
```

* <T : Any>라는 제약은 T 타입이 항상 널이 될 수 없는 타입이 되게 보장한다

## 9.2 실행 시 제네릭스의 동작 : 소거된 타입 파라미터와 실체화된 타입 파라미터

* JVM의 제네릭스는 보통 타입 소거를 사용해 구현된다. 이는 실행 시점에 제네릭 클래스의 인스턴스에 대한 타입 인자 정보가 들어있지 않다는 뜻이다

* 함수를 inline으로 만들면 타입 인자가 지워지지 않게 할 수 있다

### 9.2.1 실행 시점의 제네릭 : 타입 검사와 캐스트

```kotlin
val list1 : List<String> = listOf("a", "b", "c")
val list2 : List<Int> = listOf(1,2,3)
```

* 실행 시점에 list1이나 list2가 문자열이나 정수의 리스트로 선언됐다는 사실을 알 수 없다. 각 객체는 List일 뿐이다

* 타입 소거로 인해 타입 인자를 따로 저장하지 않으므로 실행 시점에 타입 인자를 검사할 수 없다

* 코틀린은 제네릭 함수의 본문에서 그 함수의 타입 인자를 가리킬 수 있는 특별한 기능을 제공하지 않지만 inline 함수 안에서는 타입 인자를 사용할 수 있다

### 9.2.2 실체화한 타입 파라미터를 사용한 함수 선언

* 인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다

* 함수를 인라인 함수로 만들고 타입 파라미터를 reified로 지정하면 타입을 알 수 있다

```kotlin
inline fun <reified T> isA(value : Any) = value is T
>>> println(isA<String>("abc"))
true
>>> println(isA<String>(123))
false
```

* 자바 코드에서는 reified 타입 파라미터를 사용하는 inline 함수를 호출할 수 없고 코틀린 인라인 함수를 다른 보통의 함수처럼 호출한다

* 인라인 함수에는 실체화한 타입 파라미터가 여럿 있거나 실체화한 타입 파라미터와 실체화하지 않은 타입 파라미터가 함께 있을 수 있다

### 9.2.3 실체화한 타입 파라미터로 클래스 참조 대신

### 9.2.4 실체화한 타입 파라미터의 제약

* 실체화한 타입 파라미터는 유용한 도구지만 몇가지 제약이 있다. 다음과 같은 경우에 실체화한 타입 파라미터를 사용할 수 있다
1. 타입 검사와 캐스팅(is, !is, as, as?)
2. 코틀린 리플렉션 api
3. 코틀린 타입에 대응하는 java.lang.Class를 얻기
4. 다른 함수를 호출할 때 타입 인자로 사용

* 다음과 같은 일은 할 수 없다
1. 타입 파라미터 클래스의 인스턴스 생성하기
2. 타입 파라미터 클래스의 동반 객체 메소드 호출하기
3. 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
4. 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기

* 실체화한 타입 파라미터를 인라인 함수에만 사용할 수 있으므로 실체화한 타입 파라미터를 사용하는 함수는 자신에게 전달되는 모든 람다와 함께 인라이닝된다.

* 인라이닝을 하고 싶지 않을 경우 noinline 변경자를 함수 타입 파라미터에 붙여서 인라이닝을 금지할 수 있다

## 9.3 변성

* 변성은 List<String>과 List<Any> 와 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다

### 9.3.1 변성이 있는 이유 : 인자를 함수에 넘기기

* 코틀린에서는 리스트의 변경 가능성에 따라 적절한 인터페이스를 선택하면 안전하지 못한 함수 호출을 막을 수 있다

### 9.3.2 클래스, 타입, 하위타입

* 올바른 타입을 얻으려면 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다.

* 어떤 타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무 문제가 없다면 타입 B는 타입 A의 하위 타입이다. 상위 타입은 반대

* 컴파일러는 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행한다. 어떤 값의 타입이 변수 타입의 하위 타입인 경우에만 값을 변수에 대입하게 허용한다

```kotlin
fun test(i : Int){
    val n : Number = i // Int는 Number의 하위타입이므로 컴파일 가능
    fun f(s : String) { ... }
    f(i) // Int가 String의 하위 타입이 아니므로 컴파일 불가능
}
```

* 함수에 전달하는 식의 타입이 함수 파라미터 타입의 하위 타입인 경우에만 함수 호출이 허용된다

* 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이지만 두 타입 모두 같은 클래스에 해당한다

* 제네릭 타입을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가고 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않으면 그 제네릭 타입을 **무공변**이라고 한다

* A가 B의 하위타입이고 List<A>가 List<B>의 하위타입이면 그런 클래스나 인터페이스를 **공변적**이라고 한다

### 9.3.3 공변성 : 하위 타입 관계를 유지

* 코틀린에서 제네릭 클래스가 타입 파라미터에 공변적임을 표시하려면 타입 파라미터 이름 앞에 out을 넣는다

```kotlin
interface Producer<out T> {
    fun produce() : T
}
```

* 클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다

```kotlin
open class Animal {
    fun feed() {...}
}

class Herd<T : Animal>{
    val size : Int
        get() = ...
    
    operator fun get(i : Int) : T{...}
}

fun feedAll(animals : Herd<Animal>){
    for (i in 0 until animals.size){
        animals[i].feed()
    }
}

//고양이 무리를 만들어서 관리
class Cat : Animal() {
    fun cleanLitter() {...}
}

fun takeCareOfCats(cats : Herd<Cat>){
    for (i in 0 until cats.size){
        cats[i].cleanLitter()
    }
    feedAll(cats)   //Error. Herd 클래스의 타입 파라미터에 아무 변성을 지정하지 않았기 때문에 Herd<Cat>은 Herd<Animal>의 하위클래스가 아님
    //타입 불일치를 해결하기 위해 강제 캐스팅을 할 수 있으나 올바른 방법은 아님
}

//공변적으로 바꾸면 강제 캐스팅을 하지 않고 해결 가능
class Herd<out T : Animal> {
    ...
}
```

* 클래스 멤버를 선언할 때 타입 파라미터를 사용할 수 있는 지점은 모두 in과 out 위치로 나뉜다

* T가 함수의 반환 타입에 쓰인다면 T는 아웃 위치에 있다. 그 함수는 T타입의 값을 생산한다

* T가 함수의 파라미터 타입에 쓰인다면 T는 인 위치에 있다. 그런 함수는 T타입의 값을 소모한다

* 클래스 타입 파라미터 T 앞에 out 키워드를 붙이면 클래스 안에서 T를 사용하는 메소드가 아웃 위치에서만 T를 사용하게 허용하고 인 위치에서는 T를 사용하지 못하게 막는다

* out 키워드는 T의 사용법을 제한하며 T로 인해 생기는 하위 타입 관계의 타입 안정성을 보장한다

* 타입 파라미터 T에 붙은 out 키워드는 **공변성**과 **사용 제한**을 의미한다

* **생성자 파라미터는 인이나 아웃 어느 쪽도 아니다**

```kotlin
class Herd<out T : Animal>(vararg animals : T){...} //생성자 안에 T가 쓰였으나 생성자는 상관없음
```

* 변성 규칙은 클래스 외부의 사용자가 클래스를 잘못 사용하는 일을 막기 위한 것이므로 클래스 내부 구현에는 적용되지 않는다

### 9.3.4 반공변성 : 뒤집힌 하위 타입 관계

* A가 B의 하위타입이고 List<A>가 List<B>의 상위타입이면 **반공변적**이라고 한다

```kotlin
interface Comparator<in T> {
    fun compare(e1 : T, e2 : T) : Int{...}
}
```

* in이라는 키워드는 그 키워드가 붙은 타입이 이 클래스의 메소드 안으로 전달되어 메소드에 의해 소비된다는 뜻이다

* 클래스나 인터페이스가 어떤 타입 파라미터에 대해서는 공변적이면서 다른 타입 파라미터에 대해서는 반공변적일 수도 있다

```kotlin
interface Function1<in P, out R> {
    operator fun invoke(p : P) : R
}
```

### 9.3.5 사용 지점 변성 : 타입이 언급되는 지점에서 변성 지정

* 클래스를 선언하면서 변성을 지정하면 그 클래스를 사용하는 모든 장소에 변성 지정자가 영향을 끼치므로 편리하다. 이런 방식을 **선언 지점 변성**이라고 한다

* 자바에서는 타입 파라미터가 있는 타입을 사용할 때마다 해당 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시해야한다. 이런 방식을 **사용 지점 변성**이라고 한다

### 9.3.6 스타 프로젝션 : 타입 인자 대신 * 사용

* 제네릭 타입 인자 정보가 없음을 표현하기 위해 스타 프로젝션을 사용한다

* 